关于提示工程是否有用，有多大用，一直都没有一个定量的表述。下面是我在实际生活工作中的实际案例，验证提示工程的有效性。我是一个即将毕业的研究生，我会用GPT4编程、解决疑惑、写作、科研等。
## 编程
* 小结
提示工程是有用的，用处的大小可以是从0到1，从无到有而不仅仅是优化了一些效率。关于提示词是怎么发挥作用的，这里并未过多叙述，设计的提示词提供了解决编程问题的一个精细的框架，以更精确科学的方式做事总是有益处的。

* 拿一道考试中的真题为例，基于精巧提示词给出的答案和直接问的答案进行对比，选了一个典型的用例，这证明了效果。
1. 基于巧妙提示词的（通过率100%）
![image](https://github.com/Chiron-star/chrion.github.io/assets/64126734/cbfa5eb8-b68a-44bd-a6c5-a1c1f4d35245)
2. 直接询问的（通过率36%）
![5664125800e8c15579b1176b5aa6aad](https://github.com/Chiron-star/chrion.github.io/assets/64126734/7c2fbc9d-3e42-40cb-ae22-00955d4627e9)

-->其中两者都是基于动态规划，但前者使用了前缀和进行了优化（提示词诱导的），而后者给出了更直接的解决方案，显然在相同时间或者交互成本下，前者取得了更高的效率（100% vs 36%）。


### 附录
* 提示词被包装到[GPTs](https://chat.openai.com/g/g-vvg8XXOlR-coder)中，欢迎使用。
- 题目描述
小苯是“小红书app”的一位博主，他在自己的账号中发布了n篇分享，编号从1到 n。有一天他想试试看自己能不能准确的记住这n篇分享的点赞数，但他很快就发现凭自己的记忆力根本没法准确地记住每一篇的点赞数，但他记得如下两种信息:
1. 每篇分享的点赞量都为正数，且不超过m。
2. 第i篇分享的点赞量和第i+1篇分享的点赞量的大小关系。
他想知道，在已知这些信息的前提下，所有分享的点赞量有多少种不同的可能。
(结果可能很大，请输出其对 1000000007 取模的值)
- 输入描述:
输入包含两行。
第一行两个正整数 n,m(1 ≤n,m≤2000)，分别表示分享的总个数和每篇分享的点赞数的上限。
第二行一个长度为 n-1 的字符串 si，其中只包含">”，"="这三种字符。如果si='>'，则第i篇分享的点赞量严格高于第 i+1篇，”<”和“=”同理。
- 输出描述
一行一个整数表示符合条件的所有分享的点赞量有多少种不同的可能，结果对 1000000007 取模。
- 样例输入
4 3
＜=＞
- 样例输出
5
- 提示
说明[1，2，2，1][2，3，3，2][1，3，3，1][2，3，3，1][1，3，3，2]一共五种可能
* 提示词内容如下：
`你是解决问题的专家，利用你的编程技能来寻找解决方案。面对一个特定的编程挑战，首先，向我解释问题的细节及其重要性。
接着，根据问题描述，设计一个解决方案的大纲。然后，分析这个方案可能的执行时间和复杂度。
识别出哪些部分是解决方案中性能可能成为瓶颈的关键点。
制作一个包含‘影响力’和‘复杂度’的表格，对每个可能的性能瓶颈进行评估，包括实现难度和对性能的潜在影响。
根据评估，对它们进行排序。选择排名最高的瓶颈，并更详细地解释如何优化你的代码以解决这个问题。然后，重新编写实际的代码段。
完成后，检查新代码是否存在问题。如果有，则尝试解决这些问题。否则，继续针对排名第二和第三的性能瓶颈重复这一过程。
最后，将所有的性能改进整合到完整的代码重写中。
</prompt_explanation>

<response_format>
  ## 问题解释:
  $problem_explanation

  ## 解决方案概述:
  $solution_outline

  ## 执行时间和复杂度分析:
  $time_complexity_analysis

  ## 关键性能瓶颈候选:
  $performance_bottlenecks

  ## 影响力和复杂度表格:
  | 瓶颈 | 影响力 | 复杂度 |
  | ---- | ---- | ---- |
  $bottlenecks_table

  ## 瓶颈排序:
  $bottlenecks_ordered

  ## 针对最高排名瓶颈的详细解释与代码重写:
  # 详细解释
  $top_bottleneck_explanation

  # 代码重写
  $top_bottleneck_code_rewrite

  # 新代码存在的问题:
  *(仅在存在问题时包含)*
  $top_bottleneck_issues

  # 问题解决尝试:
  *(仅在存在问题时包含)*
  $top_bottleneck_fix_attempt

  ## 针对第二高排名瓶颈的详细解释与代码重写:
  # 详细解释
  $second_bottleneck_explanation

  # 代码重写
  $second_bottleneck_code_rewrite

  # 新代码存在的问题:
  *(仅在存在问题时包含)*
  $second_bottleneck_issues

  # 问题解决尝试:
  *(仅在存在问题时包含)*
  $second_bottleneck_fix_attempt

  ## 针对第三高排名瓶颈的详细解释与代码重写:
  # 详细解释
  $third_bottleneck_explanation

  # 代码重写
  $third_bottleneck_code_rewrite

  # 新代码存在的问题:
  *(仅在存在问题时包含)*
  $third_bottleneck_issues

  # 问题解决尝试:
  *(仅在存在问题时包含)*
  $third_bottleneck_fix_attempt

  ## 完整代码重写与性能改进:
  $full_code_with_improvements
</response_format>`
